# マッチング処理実装ガイド

## 対象ファイル
`modules/matcher.py`

## このモジュールの役割
- stationid + railroad でマッチングキーを生成
- 前回データと今回データを外部結合
- 比較データ用のDataFrameを作成

---

## 実装する関数

### create_comparison_dataframe()

#### 目的
前回データと今回データをマッチングし、比較用DataFrameを作成

#### シグネチャ
```python
def create_comparison_dataframe(
    previous_df: pd.DataFrame,
    current_df: pd.DataFrame
) -> pd.DataFrame:
    """
    前回データと今回データをマッチングして比較用DataFrameを作成
    
    Args:
        previous_df: 前回データ（J列を含む）
        current_df: 今回データ（J列を含む）
    
    Returns:
        比較用DataFrame（A〜G列を含む）
    """
```

#### 実装
```python
import pandas as pd

def create_comparison_dataframe(previous_df, current_df):
    """
    前回データと今回データをマッチングして比較用DataFrameを作成
    """
    # 1. マッチングキーを作成
    previous_df = previous_df.copy()
    current_df = current_df.copy()
    
    previous_df['match_key'] = (
        previous_df['stationid'].astype(str) + '_' + 
        previous_df['railroad'].astype(str)
    )
    current_df['match_key'] = (
        current_df['stationid'].astype(str) + '_' + 
        current_df['railroad'].astype(str)
    )
    
    # 2. 必要なカラムのみ抽出
    prev_cols = ['match_key', 'stationid', 'name', 'railroad2', 'railroad', 'cityid', '新築換算平均価格']
    curr_cols = ['match_key', 'stationid', 'name', 'railroad2', 'railroad', 'cityid', '新築換算平均価格']
    
    prev_subset = previous_df[prev_cols].copy()
    curr_subset = current_df[curr_cols].copy()
    
    # 3. 外部結合（両方のデータを保持）
    merged_df = pd.merge(
        prev_subset,
        curr_subset,
        on='match_key',
        how='outer',
        suffixes=('_prev', '_curr')
    )
    
    # 4. カラムを整理
    # 基本情報は今回データ優先、なければ前回データ
    comparison_df = pd.DataFrame()
    comparison_df['stationid'] = merged_df['stationid_curr'].fillna(merged_df['stationid_prev'])
    comparison_df['name'] = merged_df['name_curr'].fillna(merged_df['name_prev'])
    comparison_df['railroad2'] = merged_df['railroad2_curr'].fillna(merged_df['railroad2_prev'])
    comparison_df['railroad'] = merged_df['railroad_curr'].fillna(merged_df['railroad_prev'])
    comparison_df['cityid'] = merged_df['cityid_curr'].fillna(merged_df['cityid_prev'])
    
    # 価格データ
    comparison_df['前回新築換算平均価格'] = merged_df['新築換算平均価格_prev']
    comparison_df['今回新築換算平均価格'] = merged_df['新築換算平均価格_curr']
    
    # 5. NaNを「データなし」に変換（価格列のみ）
    comparison_df['前回新築換算平均価格'] = comparison_df['前回新築換算平均価格'].fillna("データなし")
    comparison_df['今回新築換算平均価格'] = comparison_df['今回新築換算平均価格'].fillna("データなし")
    
    return comparison_df
```

---

## マッチングの動作パターン

### パターン1: 両方に存在
```
前回: stationid=1, railroad=JR山手線 → match_key="1_JR山手線"
今回: stationid=1, railroad=JR山手線 → match_key="1_JR山手線"
結果: マッチ成功、両方の価格が入る
```

### パターン2: 前回のみ存在
```
前回: stationid=2, railroad=東京メトロ → match_key="2_東京メトロ"
今回: （該当なし）
結果: stationid=2のレコード作成、今回価格は「データなし」
```

### パターン3: 今回のみ存在
```
前回: （該当なし）
今回: stationid=3, railroad=JR中央線 → match_key="3_JR中央線"
結果: stationid=3のレコード作成、前回価格は「データなし」
```

---

## テストコード例

### tests/test_matcher.py
```python
import sys
sys.path.append('..')

from modules.matcher import create_comparison_dataframe
import pandas as pd

def test_matching():
    """
    マッチング処理のテスト
    """
    # 前回データ
    previous_df = pd.DataFrame({
        'stationid': [1, 2],
        'name': ['東京', '新宿'],
        'railroad2': ['JR', 'JR'],
        'railroad': ['JR山手線', 'JR山手線'],
        'cityid': [13101, 13104],
        '新築換算平均価格': [9000000, 8500000]
    })
    
    # 今回データ
    current_df = pd.DataFrame({
        'stationid': [1, 3],
        'name': ['東京', '渋谷'],
        'railroad2': ['JR', 'JR'],
        'railroad': ['JR山手線', 'JR山手線'],
        'cityid': [13101, 13113],
        '新築換算平均価格': [9500000, 9200000]
    })
    
    # マッチング実行
    comparison_df = create_comparison_dataframe(previous_df, current_df)
    
    print("比較データ:")
    print(comparison_df)
    
    # 検証
    assert len(comparison_df) == 3, "レコード数エラー（両方+前回のみ+今回のみ=3）"
    
    # stationid=1（両方存在）
    row1 = comparison_df[comparison_df['stationid'] == 1].iloc[0]
    assert row1['前回新築換算平均価格'] == 9000000, "前回価格エラー"
    assert row1['今回新築換算平均価格'] == 9500000, "今回価格エラー"
    
    # stationid=2（前回のみ）
    row2 = comparison_df[comparison_df['stationid'] == 2].iloc[0]
    assert row2['前回新築換算平均価格'] == 8500000, "前回価格エラー"
    assert row2['今回新築換算平均価格'] == "データなし", "今回価格エラー（データなしのはず）"
    
    # stationid=3（今回のみ）
    row3 = comparison_df[comparison_df['stationid'] == 3].iloc[0]
    assert row3['前回新築換算平均価格'] == "データなし", "前回価格エラー（データなしのはず）"
    assert row3['今回新築換算平均価格'] == 9200000, "今回価格エラー"
    
    print("✅ テスト成功")

if __name__ == '__main__':
    test_matching()
```

---

## 実装時のチェックリスト

- [ ] stationid + railroad を文字列結合してキー生成
- [ ] pd.merge() で `how='outer'` を使用
- [ ] suffixes で '_prev', '_curr' を指定
- [ ] fillna() で値の優先順位を設定
- [ ] 価格列のNaNは「データなし」に変換

---

## 次のステップ

**09_メイン処理実装ガイド.md を読んで、data_processor.pyを実装してください**