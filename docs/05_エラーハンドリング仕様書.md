# エラーハンドリング仕様書

## エラー処理の基本方針

1. **早期検出**: ファイルアップロード直後にバリデーション
2. **明確なメッセージ**: ユーザーが理解できる日本語メッセージ
3. **処理継続**: 可能な限り部分的なエラーは「データなし」で継続
4. **ログ記録**: 開発者向けに詳細ログを出力（本番では非表示）

---

## エラー分類

### レベル1: 致命的エラー（処理中断）

処理を続行できないエラー

| エラー種別 | 検出タイミング | ユーザーメッセージ |
|-----------|----------------|-------------------|
| ファイル未選択 | ボタン押下時 | ⚠️ 両方のファイルをアップロードしてください |
| ファイル形式エラー | アップロード時 | ❌ .xlsx形式のファイルをアップロードしてください |
| 必須カラム不足 | 読み込み後 | ❌ 必須カラム（stationid, railroad）が見つかりません |
| ヘッダー行なし | 読み込み後 | ❌ ファイル構造が不正です（2行目にヘッダーが必要） |
| データ行なし | 読み込み後 | ❌ データ行が見つかりませんでした |

### レベル2: 警告（処理継続、一部データに影響）

| 警告種別 | 対処方法 | ユーザーメッセージ |
|----------|----------|--------------------|
| 計算元が空白 | 「データなし」代入 | （メッセージなし、結果に反映） |
| 計算元が0 | 「データなし」代入 | （メッセージなし、結果に反映） |
| マッチング失敗 | 片方の値のみ表示 | （メッセージなし、結果に反映） |
| 除算ゼロ | 「データなし」代入 | （メッセージなし、結果に反映） |

---

## ファイルバリデーション

### utils/file_validator.py の実装
```python
import pandas as pd


def validate_file(file, file_name):
    """
    ファイルの妥当性を検証

    Args:
        file: Streamlitのアップロードファイル
        file_name: ファイル名（エラーメッセージ用）

    Raises:
        ValueError: バリデーションエラー
    """
    # 1. 拡張子チェック
    if not file.name.endswith('.xlsx'):
        raise ValueError(f"{file_name}: .xlsx形式のファイルをアップロードしてください")

    try:
        # 2. Excel読み込みテスト
        df = pd.read_excel(file, header=1)

        # 3. ヘッダー行の存在チェック
        if df.empty:
            raise ValueError(f"{file_name}: データ行が見つかりませんでした")

        # 4. 必須カラムチェック
        required_columns = ['stationid', 'railroad']
        missing_columns = [col for col in required_columns if col not in df.columns]

        if missing_columns:
            raise ValueError(
                f"{file_name}: 必須カラムが見つかりません - {', '.join(missing_columns)}"
            )

        # 5. データ行の存在チェック
        if len(df) < 1:
            raise ValueError(f"{file_name}: データ行が見つかりませんでした")

        # ファイルポインタをリセット（ファイルオブジェクトの場合のみ）
        if hasattr(file, 'seek'):
            file.seek(0)

    except Exception as e:
        if isinstance(e, ValueError):
            raise
        else:
            raise ValueError(f"{file_name}: ファイル読み込みエラー - {str(e)}")
```

---

## 計算時のエラー処理

### modules/calculator.py でのエラーハンドリング
```python
import pandas as pd
import math

def safe_calculate(value, calculation_func, error_return="データなし"):
    """
    安全な計算実行（エラー時は指定値を返す）
    
    Args:
        value: 計算対象の値
        calculation_func: 計算関数
        error_return: エラー時の戻り値
    
    Returns:
        計算結果 or error_return
    """
    try:
        if pd.isna(value) or value == 0:
            return error_return
        
        result = calculation_func(value)
        
        # 無限大・NaNチェック
        if math.isinf(result) or math.isnan(result):
            return error_return
        
        return result
    
    except Exception:
        return error_return


def calculate_with_error_handling(row, column_name, calculation_func):
    """
    DataFrameの行に対して安全に計算を実行
    
    Args:
        row: DataFrame の行
        column_name: 対象カラム名
        calculation_func: 計算関数
    
    Returns:
        計算結果 or "データなし"
    """
    value = row[column_name]
    return safe_calculate(value, calculation_func)
```

### 使用例
```python
# J列の計算
df['新築換算平均価格'] = df.apply(
    lambda row: calculate_with_error_handling(
        row, 
        'priceunitconvnewly',
        lambda x: round(x * 0.3025 * 70, 0)
    ),
    axis=1
)
```

---

## マッチング時のエラー処理

### modules/matcher.py でのエラーハンドリング
```python
def create_comparison_data(previous_df, current_df):
    """
    比較データ作成（マッチング失敗も含める）
    
    Args:
        previous_df: 前回データ
        current_df: 今回データ
    
    Returns:
        比較用DataFrame
    """
    try:
        # マッチングキー作成
        previous_df['match_key'] = (
            previous_df['stationid'].astype(str) + '_' + 
            previous_df['railroad'].astype(str)
        )
        current_df['match_key'] = (
            current_df['stationid'].astype(str) + '_' + 
            current_df['railroad'].astype(str)
        )
        
        # 外部結合（両方のデータを保持）
        merged_df = pd.merge(
            previous_df,
            current_df,
            on='match_key',
            how='outer',
            suffixes=('_prev', '_curr')
        )
        
        # 欠損値処理
        for col in ['stationid', 'name', 'railroad', 'railroad2', 'cityid']:
            # 今回データ優先、なければ前回データ
            merged_df[col] = merged_df[f'{col}_curr'].fillna(merged_df[f'{col}_prev'])
        
        return merged_df
    
    except Exception as e:
        raise ValueError(f"マッチング処理でエラーが発生しました: {str(e)}")
```

---

## エラーメッセージ一覧

### app.py で使用するメッセージ
```python
ERROR_MESSAGES = {
    'file_not_selected': "⚠️ 両方のファイルをアップロードしてください",
    'invalid_format': "❌ .xlsx形式のファイルをアップロードしてください",
    'missing_columns': "❌ 必須カラム（stationid, railroad）が見つかりません",
    'no_header': "❌ ファイル構造が不正です（2行目にヘッダーが必要）",
    'no_data': "❌ データ行が見つかりませんでした",
    'processing_error': "❌ 処理中にエラーが発生しました",
    'unknown_error': "❌ 予期しないエラーが発生しました",
}

SUCCESS_MESSAGES = {
    'file_uploaded': "✅ ファイルをアップロードしました",
    'processing_complete': "✅ 処理が完了しました！",
}

INFO_MESSAGES = {
    'waiting_files': "💡 両方のファイルをアップロードしてください",
    'waiting_process': "💡 処理を実行すると、ダウンロードボタンが表示されます",
    'processing': "🔄 処理中です...しばらくお待ちください",
}
```

---

## エラー処理フロー
```
ファイルアップロード
  ↓
┌─ バリデーション ─────────┐
│ - 拡張子チェック          │ → エラー時: st.error()
│ - Excel読み込み          │    処理中断
│ - カラムチェック         │
└──────────────────────────┘
  ↓ OK
データ読み込み
  ↓
┌─ 計算処理 ───────────────┐
│ - J〜M列計算             │ → エラー時: "データなし"
│ - エラーハンドリング     │    処理継続
└──────────────────────────┘
  ↓
┌─ マッチング処理 ─────────┐
│ - キー生成               │ → エラー時: st.error()
│ - 外部結合               │    処理中断
└──────────────────────────┘
  ↓
┌─ 比較データ計算 ─────────┐
│ - 差異計算               │ → エラー時: "データなし"
│ - 値上げ率計算           │    処理継続
└──────────────────────────┘
  ↓
┌─ Excel出力 ──────────────┐
│ - 3シート生成            │ → エラー時: st.error()
│ - BytesIO出力            │    処理中断
└──────────────────────────┘
  ↓
処理完了
```

---

## デバッグ用ログ出力

### 開発時のみ有効化
```python
import logging

# app.pyの冒頭で設定
DEBUG_MODE = True  # 本番ではFalse

if DEBUG_MODE:
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(__name__)
else:
    logging.basicConfig(level=logging.ERROR)
    logger = logging.getLogger(__name__)

# 使用例
logger.debug(f"前回データ読み込み: {len(df_prev)}行")
logger.error(f"エラー発生: {str(e)}")
```

---

## 次のステップ

**これで設計書の確認は完了です。**
**次は 06_Excel読み書き実装ガイド.md を読んで、実装を開始してください。**